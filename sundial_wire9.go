// MACHINE GENERATED BY 'go generate' COMMAND
// TO EDIT A TYPE OR METHOD, COPY IT TO ANOTHER FILE IN THE PACKAGE
package git

import (
	"bufio"
	"bytes"
	"compress/zlib"
	"encoding/binary"
	"fmt"
	"io"
)

func writestring(w io.Writer, s string, must int) (err error) {
	data := []byte(s)
	switch l := len(data); {
	case l > must:
		_, err = w.Write(data[:must])
	case l < must:
		_, err = w.Write(data[:l])
		if err != nil {
			return err
		}
		underflow := must - l
		_, err = w.Write(bytes.Repeat([]byte{0x00}, underflow))
	default:
		_, err = w.Write(data[:l])
	}
	return err
}

func ioErr(name, kind string, ac, ex int) error {
	return fmt.Errorf("%s: short %s: %d/%d", name, kind, ac, ex)
}

type gitTran struct {
	n    stringInt
	data []byte
}

type zobject struct {
	info *Info
	data []byte
}

type packhdr struct {
	sig     uint32
	ver     uint32
	n       uint32
	objects []zobject
}

func (z *gitTran) ReadBinary(r io.Reader) (err error) {
	defer func() {
		r := recover()
		if r == nil {
			return
		}
		if r, ok := r.(error); ok {
			err = r
			return
		}
		panic(r)
	}()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.n.ReadBinary(r); err != nil {
		return err
	}

	z.data = make([]byte, int(z.n))

	if n, err := r.Read(z.data); err != nil || n != int(z.n) {
		if err != nil {
			return err
		}
		return fmt.Errorf("expected %d bytes, got %d", int(z.n), n)
	}

	return nil
}

func (z *gitTran) WriteBinary(w io.Writer) (err error) {
	defer func() {
		r := recover()
		if r == nil {
			return
		}
		if r, ok := r.(error); ok {
			err = r
			return
		}
		panic(r)
	}()

	if err := z.n.WriteBinary(w); err != nil {
		return err
	}

	{
		x := int(z.n)
		if n, err := w.Write(z.data[:x]); err != nil || n != x {
			return err
		}
	}
	return nil
}

func (z *zobject) ReadBinary(r io.Reader) (err error) {
	defer func() {
		r := recover()
		if r == nil {
			return
		}
		if r, ok := r.(error); ok {
			err = r
			return
		}
		panic(r)
	}()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	z.info = &Info{}

	buf := new(bytes.Buffer)
	zsize, err := buf.ReadFrom(r)
	if err != nil {
		return fmt.Errorf("zobject: ReadBinary: buf.ReadFrom: %v", err)
	}

	if err := z.info.ReadBinary(buf); err != nil {
		return fmt.Errorf("zobject: z.info.ReadBinary: %v", err)
	}

	var scratch [20]byte
	z.data = make([]byte, z.info.Size)
	switch t := z.info.PackType; t {
	case 0:
		fmt.Println("zero")
	case PackOffDelta:
		v, n := binary.Varint(buf.Bytes()[:10])
		if n == -1 {
			return fmt.Errorf("bad varint")
		}
		buf.Next(n)
		fmt.Printf("v=%d n=%d zsize=%d sub=%d\n", v, n, zsize, v-int64(zsize))
	case PackCommit:
	case PackTree:
	case PackBlob:
	case PackTag:
	case PackRefDelta:
		buf.Read(scratch[:])
		fmt.Printf("PackRefDelta: %x\n", scratch[:])
	default:
		panic(t)
	}

	zr, err := zlib.NewReader(buf)
	if err != nil {
		return fmt.Errorf("zobject: zlib.NewReader: %v", err)
	}

	if n, err := zr.Read(z.data); (err != nil && err != io.EOF) || n != int(z.info.Size) {
		if err != nil {
			return fmt.Errorf("zobject: zr.Read: %d/%d: %v", z.info.Size, n, err)
		}
		return fmt.Errorf("expected %d bytes, got %d", z.info.Size, n)
	}
	z.info.Size = int(zsize) - len(buf.Bytes())
	return zr.Close()
}

func (z *zobject) WriteBinary(w io.Writer) (err error) {
	defer func() {
		r := recover()
		if r == nil {
			return
		}
		if r, ok := r.(error); ok {
			err = r
			return
		}
		panic(r)
	}()

	if err := z.info.WriteBinary(w); err != nil {
		return err
	}

	{
		x := int(z.info.Size)
		if n, err := w.Write(z.data[:x]); err != nil || n != x {
			return err
		}
	}
	return nil
}

func (z *packhdr) ReadBinary(r io.Reader) (err error) {
	defer func() {
		r := recover()
		if r == nil {
			return
		}
		if r, ok := r.(error); ok {
			err = r
			return
		}
		panic(r)
	}()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.BigEndian, &z.sig); err != nil {
		return err
	}

	if err := binary.Read(r, binary.BigEndian, &z.ver); err != nil {
		return err
	}

	if z.ver != 2 {
		return fmt.Errorf("packhdr is version %d", z.ver)
	}

	if err := binary.Read(r, binary.BigEndian, &z.n); err != nil {
		return err
	}

	z.objects = make([]zobject, int(z.n))
	buf := new(bytes.Buffer)
	_, err = buf.ReadFrom(r)
	if err != nil {
		return err
	}
	for i := 0; i < int(z.n); i++ {
		q := bytes.NewReader(buf.Bytes())
		if err := z.objects[i].ReadBinary(bufio.NewReader(q)); err != nil {
			return fmt.Errorf("packhdr: ReadBinary: objects[%d]: %v", i, err)
		}
		buf.Next(int(z.objects[i].info.Size))
	}

	return nil
}

func (z *packhdr) WriteBinary(w io.Writer) (err error) {
	defer func() {
		r := recover()
		if r == nil {
			return
		}
		if r, ok := r.(error); ok {
			err = r
			return
		}
		panic(r)
	}()

	if err := binary.Write(w, binary.BigEndian, z.sig); err != nil {
		return err
	}

	if err := binary.Write(w, binary.BigEndian, z.ver); err != nil {
		return err
	}

	if err := binary.Write(w, binary.BigEndian, z.n); err != nil {
		return err
	}

	z.objects = make([]zobject, int(z.n))
	for i := 0; i < int(z.n); i++ {
		if err := z.objects[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}
